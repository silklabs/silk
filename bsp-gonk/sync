#!/bin/bash

cd $(dirname $0)

board=$(readlink .repo/board)
product=$(readlink .repo/product)
default_board=$(readlink board/.default)
default_product=$(readlink product/.default)

usage () {
  local exitcode=0
  if [[ -n ${1:-} ]]; then
    exitcode=1
    echo Error: $@
    echo
  fi
  echo "usage: $0 [board] [product]"
  echo
  echo Prepares the workspace for building the specified board/product
  echo
  if [[ -d board ]]; then
    cd board
    echo Available boards:
    for board in *; do
      if [[ -r $board/gonk.sh ]]; then
        maybe_default=
        if [[ $default_board = $board ]]; then
          maybe_default="(default)"
        fi
        echo "  * $board $maybe_default"
      fi
    done
    cd ..
  else
    echo "No boards available"
  fi

  echo
  if [[ -d product ]]; then
    cd product
    echo Available products:
    for product in *; do
      if [[ -r $product/$product.xml ]]; then
        maybe_default=
        if [[ $default_product = $product ]]; then
          maybe_default="(default)"
        fi
        echo "  * $product $maybe_default"
      fi
    done
    cd ..
  else
    echo "No products available"
  fi
  exit $exitcode
}

repo=${REPO:-./repo}
repo_init_host=$(uname | tr A-Z a-z)
repo_init_version="--repo-url=git://codeaurora.org/tools/repo.git --repo-branch=caf-stable"
repo_sync_j=-j4

sync_l=true
sync_n=true

while getopts "h?nl" opt; do
  case $opt in
  h|\?)
    usage
    ;;
  n)
    sync_n=true
    sync_l=false
    shift
    ;;
  l)
    sync_n=false
    sync_l=true
    shift
    ;;
  *)
    usage Unknown option: $opt
    ;;
  esac
done

[[ $# -le 2 ]] || usage

arg_board=${1:-}
arg_product=${2:-}

board=${arg_board:-$board}
board=${board:-$default_board}

product=${arg_product:-$product}
product=${product:-$default_product}

[[ -n $board ]] || usage board is not defined
[[ -n $product ]] || usage product is not defined
[[ -d board/$board ]] || usage board directory missing: board/$board/
[[ -d product/$product ]] || usage product directory missing: product/$product/
[[ -r board/$board/$board.xml ]] || usage board manifest missing: board/$board/$board.xml
[[ -r product/$product/$product.xml ]] || usage product manifest missing: product/$product/$product.xml

set -e

mkdir -p .repo
ln -fs $board .repo/board
ln -fs $product .repo/product

if [[ ! -d .repo/.git ]]; then
  # Construct an empty .git in .repo/ to prevent |git clean -dfx| from removing
  # the hard-earned contents of .repo/{projects,project-objects}
  mkdir -p .repo
  cd .repo
  git init --quiet .
  git commit --allow-empty -m 'Empty'
  cd ..
fi

# Recreate the ephemeral manifest projects
rm -rf .repo/manifest_upstream
rm -rf .repo/manifests
rm -rf .repo/manifests.git

# Construct a faux 'upstream' manifest project to keep repo content.  Its
# manifest .xml files redirect out to {board,product}/*/*.xml so that local
# edits to manifest files will be picked up immediately by a |repo sync|
allmanifests=({board,product}/*/*.xml)
mkdir -p .repo/manifest_upstream
cd .repo/manifest_upstream
git init --quiet .
for f in ${allmanifests[@]}; do
  ln -sf ../../$f .
done

echo '<?xml version="1.0"?>' > default.xml
cat >> default.xml <<MANIFEST
<manifest>
  <!-- Autogenerated by $0 -->
  <include name="$board.xml"/>
  <include name="$product.xml"/>
</manifest>
MANIFEST

git add *
git commit -q -m '301 Moved Permanently'
cd ../..
pwd
# Re-init the real manifest
$repo init \
  --quiet \
  -u $PWD/.repo/manifest_upstream \
  $repo_init_version \
  -g all,-notdefault,-x86,-mips,-linux,-darwin,-flo,-flounder,-fugu,-grouper,-manta,$repo_init_host \


if $sync_n; then
  ./repocache fetch $board $product
  $repo sync -n $repo_sync_j --quiet --current-branch --no-tags
fi
if $sync_l; then
  $repo sync -l --quiet
  touch .repo/lastsync

  # Force re-patching on next build/envsetup.sh
  ( set -x; rm -f out/lastpatch.md5sum )
fi
